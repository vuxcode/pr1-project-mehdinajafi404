<!DOCTYPE html>
<html lang="en">

<head>
    <title>Yellow</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <!--I'm using CSS here to add margins and colours. I find it easier this way-->
    <style>
        body {
        text-align: center;
        background: #111;
        color: white;
        margin: 0;
        padding: 0;
        }

        #gameTitle {
        text-align: center;
        margin-bottom: 10px;
        font-size: 28px;
        font-weight: bold;
    }
        canvas {
        border: 2px solid #3d1f5b;
        display: block;
        margin: 20px auto;
        }

        #controls {
        margin-top: 15px;   /* Space above button */
        }

        #resetBtn {
        padding: 10px 20px;
        font-size: 16px;
        font-weight: bold;
        border: 2px solid #3d1f5b;
        }

    </style>

</head>

<!--Body is where we hold all the visible contents-->
<body>

<h1 id="gameTitle">Yellow vs. The Maze</h1>

<!--Giving the canvas a name and size-->
<canvas id="MazeCanvas" width="680" height="440"></canvas>

<!--Creating a container for the buttons so that I can customize later-->
  <div id="controls">
    <button id="resetBtn">Reset</button>
  </div>

    <script>
       
        // Creating variables for canvas
        var canvas = document.getElementById('MazeCanvas');
        // The context or ctx variable is what gives us the ability to draw in 2d on the canvas.
        var ctx = canvas.getContext('2d');

        // Creating the tiles and it's size and amount.
        // The Canvas is 680 pixels wide, if we devide it by 40 it gives us 17 squares.
        // And the height would be 11 squares. 
        var squareSize = 40; //size of the square in pixels, if we use 1, 2, 4, 5, 8, 10, 20 but the goal will be blocked.
        /* With squareSize = 40, the grid is 17Ã—11 (odd), so the DFS reaches the goal. With squareSize = 20, the grid is 34Ã—22 (even), 
        so DFS skips cells in twos and canâ€™t reach the bottom-right, blocking the goal.*/
        // Math.floor rounds a number down to the nearest whole number
        var horizontalSquares = Math.floor(canvas.width / squareSize); //17 squares horizontally
        var verticalSquares = Math.floor(canvas.height / squareSize); //11 squares vertically

        // Creating the player
        // x is horizontal player position and y is vertical player position
        //Position: Top left corner
        var player = { x: 0, y: 0, color: 'yellow' };

        // Creating the goal, buttom right corner.
        //We subtract 1 because the grid squares are numbered from 0
        //so the last square is always one less than the total number of squares.
        var goal = {x: horizontalSquares - 1, y: verticalSquares - 1};

        // Creating a variable for the maze
        var maze = [];

        // Creating a Function to generate a maze using the alghorithm.
        function mazeAlghorithm(){
        
        // First I'm filling the maze completely with walls (1s)
        maze = []; // Start with an empty array to hold the maze
        
        //This line starts a loop that goes through each row of the maze
        // var y=0 - start at the first row (top).
        // y<verticalSquares - keep going until you reach the number of rows in the maze.
        // y++ move down one row each time,
        for(var y=0; y<verticalSquares; y++){ 
        maze[y]=[]; // For this row number y, create an empty array to hold that rowâ€™s cells
        
        for(var x=0; x<horizontalSquares; x++) // Loop through each column
        maze[y][x]=1; // Set every cell in the grid to 1 so the whole maze starts filled with walls
        }

        // Here, Iâ€™m using recursion. In the code, recursion occurs when "carve()" calls itself with the coordinates of the next cell, 
        // -allowing the algorithm to dig paths through the maze automaticallyâ€”moving deeper in one direction and
        //  -backtracking when it hits a dead end.    
        // creating a function to carve paths. we're simply making the random maze alghorithn here.
        // we're defining the function "carve" that digs paths starting from tile (x, y).
        // c-columnn and c-row are parameters.They donâ€™t have a value until you call carve(0, 0) (then x=0, y=0).
        function carve(currentColumn,currentRow){
        maze[currentRow][currentColumn]=0; // mark current cell as empty/path. 
        
        // creating an array that stores all the possible directions- 
        // -the algorithm can move from the current cell.
        // for example [1, 0] means go 1 cell right, 0 cells down. move right.
        // This line builds a list of the four possible ways to move in the grid (up, right, down, left).
        var direction=[[0,-1],[1,0],[0,1],[-1,0]];
        
        // Shuffle directions to make maze random
            // This loop walks backwards through the direction list to prepare it for shuffling
            // currentIndex starts at the last item.
            // Keep looping as long as currentIndex is bigger than 0
            // Subtract 1 from currentIndex after every loop
        for(var currentIndex=direction.length-1; currentIndex>0;currentIndex--){
            // Pick a random index from the array to swap with.
            var randomIndex=Math.floor(Math.random()*(currentIndex+1));
            // Swap the direction at currentIndex with the direction at randomIndex
            [direction[currentIndex],direction[randomIndex]] = [direction[randomIndex],direction[currentIndex]];
            }
        
        // Here, Backtracking works with recursion: when the path canâ€™t go forward, 
        // -the function goes back to the previous cell and tries a new direction. 
        // -This makes sure the maze stays connected and nothing gets stuck or left out.
        // Try moving in each direction
            
        // Here Fisherâ€“Yates Shuffle is used to randomize the order of possible directions, 
        // -making each maze unpredictable instead of following the same repetitive pattern.
        // Loop through each possible direction (up, right, down, left) one by one.
        for(var currentIndex=0;currentIndex<direction.length;currentIndex++){
            //Calculate the x-coordinate of the next cell we would move to in this direction.
            // the algorithm moves two cells at a time, leaving a wall in between. 
            // -this ensures that walls remain between paths, giving the maze its proper structure. 
            // -without this, the maze would just be empty tiles with no walls separating paths.
            var nextCellX=currentColumn+direction[currentIndex][0]*2; // Move 2 cells to skip a wall in between. 
            // Calculate the y-coordinate...
            var nextCellY=currentRow+direction[currentIndex][1]*2; 
            
        // Check if the next cell is inside the maze boundaries and hasnâ€™t been carved yet.
        if(nextCellX>=0 && nextCellX<horizontalSquares && nextCellY>=0 && nextCellY<verticalSquares && maze[nextCellY][nextCellX]===1){
            // Carve the wall between the current cell (x, y) and the next cell (nextCellX, nextCellY) to connect the path.
            maze[currentRow+direction[currentIndex][1]][currentColumn+direction[currentIndex][0]]=0; // Remove wall between
            // Call the same carve function.
            // Pass the coordinates of the next cell.
            // Go to the next cell and repeat the carving process from there.
            // This is how the maze digs paths deeply and automatically backtracks.
            carve(nextCellX,nextCellY); // Recursive call to carve next cell
                }
            }
        }   

        carve(0,0); //Begin the maze generation at the top-left corner. The algorithm will start digging paths from here.
        maze[0][0]=0; //Ensure the starting point is always open, even if the algorithm would have accidentally left it as a wall.
        maze[verticalSquares-1][horizontalSquares-1]=0; //Guarantee the goal cell is open, so the maze is solvable.
        }
        

        // Creating a variable to store random wall colours when it's revealed.
        var wallColors = {}; 

        // Generates a random bright color using HSL
        function randomColor() {
        //Whenever I call randomColor(), it returns a new color.
        //Math.random() Generates a random decimal number between 0 and 1 (0 and 1 are not included)
        //Multiplies that decimal by 360
        //Why 360?
        // HSL (Hue, Saturation, Lightness) color uses Hue as a degree on a color wheel from 0Â° to 360Â°.
        // 0Â° = red, 120Â° = green, 240Â° = blue, etc
        // Combines the hue with saturation and lightness to make a full HSL color string.
        // "80%" - how intense the color is (saturation).
        // "50%" - how bright the color is (lightness).
        // example "hsl(300, 80%, 50%)" is bright purple
        // Math.floor Rounds the number down to the nearest whole number
        return "hsl(" + Math.floor(Math.random() * 360) + ", 80%, 50%)";
        }

        // Function to draw grid and player
        function draw() {
                // Clear the canvas
                // Before drawing anything, we erase the whole canvas. so we don't draw stuff on top of old drawings.
                // ctx is my canvasâ€™s drawing tool. Like a digital paintbrush.
                // clearRect erases a rectangle.
                // 0, 0 are the starting coordinates of the rectangle you want to erase.
                // width and height is the size of the rectangle we want to clear.
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw the grid
                //creating a for-loop to go through each row to help draw the maze grid
                // Start at the first row, Keep going until you've reached the last row, Move down one row every time.
                for (var columnIndex = 0; columnIndex < verticalSquares; columnIndex++) {
                    //Start at the first column, Move across the row until you reach the last column, Shift one step right each time.
                    for (var rowIndex = 0; rowIndex < horizontalSquares; rowIndex++) {
                       //If this square is a path, paint it black.
                       // maze y,x means if the square inside the maze at row y and column x is exaclty 0 paint it black.
                        if (maze[columnIndex][rowIndex] === 0) {
                            ctx.fillStyle = '#111';  
                        }
                        //If itâ€™s a hidden wall, also paint it dark.
                        else if (maze[columnIndex][rowIndex] === 1) {
                            ctx.fillStyle = '#222';   // hidden wall (black)
                        }
                        //If itâ€™s a revealed wall, use its saved random color.
                         else if (maze[columnIndex][rowIndex] === 2) {
                        ctx.fillStyle = wallColors[columnIndex + "-" + rowIndex];
                        }
                        // x * squareSize - Convert tile X into pixel X
                        // the last two squareSize are for the square width and height.
                        // So this draws a perfect square.
                        ctx.fillRect(rowIndex * squareSize, columnIndex * squareSize, squareSize, squareSize);
                        //The border color for the square.
                        ctx.strokeStyle = '#111';
                        //draws the border around the square.
                        ctx.strokeRect(rowIndex * squareSize, columnIndex * squareSize, squareSize, squareSize);
                    }
                }
                
                // Coloring and drawing the goal.
                ctx.fillStyle = 'white';
                ctx.fillRect(goal.x * squareSize, goal.y * squareSize, squareSize, squareSize);

                // Draw the player
                ctx.fillStyle = player.color;
                
                // Here we're doing the same multiplying players position with the squareSize 
                // to convert from tile units to pixels
                // We use the same value (squareSize) for width and height
                // because each tile in the maze is a square
                ctx.fillRect(player.x * squareSize, player.y * squareSize, squareSize, squareSize);
        }

        
        mazeAlghorithm(); // fill maze with walls and paths and random colours to be revealed
        draw(); // Now that the maze exists, draw it on the screen.

        // Function to move player
        // horizontalMove is how many squares to move left or right.
        // verticalMove is how many squares to move up or down.
        function movePlayer(horizontalMove, verticalMove) {
            
            // newCol is the new x-position after moving left/right.
            // player.x is where the player is now on the grid (like column number).
            // horizontalMove is how much you want to move left or right.
            // example: â€œIâ€™m at column 3, I want to move 1 to the right, new column is 4.â€
            var newCol = player.x + horizontalMove;
            
            //newRow is the new y-position after moving up/down.
            var newRow = player.y + verticalMove;

            // Keep player inside the maze
            // newCol >= 0 â†’ Makes sure the new horizontal position isnâ€™t less than 0 (the far left of the grid).
            // newCol < horizontalSquares â†’ Makes sure the new horizontal position is inside the grid width.
            // newRow >= 0 â†’ Makes sure the new vertical position isnâ€™t less than 0 (the top of the grid).
            // newRow < verticalSquares â†’ Makes sure the new vertical position is inside the grid height
            // Combined with && â†’ all conditions must be true for the code inside the if to run
            if (newCol >= 0 && newCol < horizontalSquares && newRow >= 0 && newRow < verticalSquares) {
            
            // Check if the new position is a path (0)
            // If it's a path - move normally
            // maze is our map of the game. It tells us which spots are walls and which are paths.
            if (maze[newRow][newCol] === 0) {
            player.x = newCol;
            player.y = newRow;
            checkWin();
            }
            
            // If it's a wall (1) - reveal it (turn 1 into 2)
            else if (maze[newRow][newCol] === 1) {
            maze[newRow][newCol] = 2; // mark as revealed wall
            
            // Combines the row and column numbers into a string key.
            // Example: if newRow = 3 and newCol = 5, the key becomes "3-5".'
            // randomColor() This function returns a random color.
            // It assigns a color specifically for this wall square.
            wallColors[newRow + "-" + newCol] = randomColor();
            }
            }

            // Redraw everything
            //Every time the player moves, the canvas needs to be redrawn. 
            draw();
        }

        // Check if player reaches goal
        function checkWin() {
        
        // If player is in the same column, row as the goal.
        // Then we get the allert.
          if(player.x === goal.x && player.y === goal.y){
        alert("ðŸŽ‰ You made it! Press OK for a new random maze.");
        player.x = 0; player.y = 0;
        mazeAlghorithm();
        draw();
        }
        }

        // Arrow keys 
        // Using keyup means you have to press the button and then release it to move the player.
        // you can also use keydown for smoother movement.
        // Listen for when a key is released (not pressed down).
        //When a key is released, run this code. event contains info about which key was released.
       document.addEventListener('keyup', function(event) {
        //Check if the released key is the up arrow or w
        if (event.key === "ArrowUp"|| event.key === "w") { 
        //If it was the up arrow or w key, move the player up by 1 square.
        //first number is the horizontal move, second number is the vertical move
        movePlayer(0, -1); 
        } else if (event.key === "ArrowDown"|| event.key === "s") {
        movePlayer(0, 1);  
        } else if (event.key === "ArrowLeft"|| event.key === "a") {
        movePlayer(-1, 0); // we don't move the player horizontally so the Up and down movement stays 0. 
        } else if (event.key === "ArrowRight"|| event.key === "d") {
        movePlayer(1, 0);  
        }
        });


        //The "click" here tells the browser when to run the code. It means â€œwhen the user clicks this buttonâ€.
        // It resets the players position and the maze and redraws it. 
        document.getElementById('resetBtn').addEventListener('click', function(){
        player.x=0; player.y=0;
        mazeAlghorithm();
        draw();
        });
        
        console.log();
    </script>

</body>

</html>