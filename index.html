<!DOCTYPE html>
<html lang="en">

<head>
    <title>Yellow</title>
    
    <!--I'm using CSS here to add margins and colours. I find it easier this way-->
    <style>
        body {
        text-align: center;
        background: #111;
        color: white;
        margin: 0;
        padding: 0;
        }

        #gameTitle {
        text-align: center;
        margin-bottom: 10px;
        font-size: 28px;
        font-weight: bold;
    }
        canvas {
        margin-top: 20px;
        border: 2px solid #3d1f5b;
        display: block;
        margin: 20px auto;
        }

        #controls {
        margin-top: 15px;   /* Space above button */
        }

        #resetBtn {
        padding: 10px 20px;
        font-size: 16px;
        font-weight: bold;
        border: 2px solid #3d1f5b;
        }

    </style>

</head>

<!--Body is where we hold all the visible contents-->
<body>

<h1 id="gameTitle">Yellow vs. The Maze</h1>

<!--Giving the canvas a name and size-->
<canvas id="MazeCanvas" width="680" height="440"></canvas>

<!--Creating a container for the buttons so that I can customize later-->
  <div id="controls">
    <button id="resetBtn">Reset</button>
    <!--<button id="restartBtn">Restart</button>-->
  </div>

    <script>
       
        // Creating variables for canvas
        var canvas = document.getElementById('MazeCanvas');
        // The context or ctx is what gives us the ability to draw in 2d on the canvas.
        var ctx = canvas.getContext('2d');

        // Creating the tiles and it's size and amount.
        var tileSize = 40; //size of the square in pixels
        var cols = Math.floor(canvas.width / tileSize); //Counts full tiles across horizontally
        var rows = Math.floor(canvas.height / tileSize); // ... vertically

        // Creating the player
        // Position: Top left corner
        // x is horizontal player position and y is vertical player position
        var player = { x: 0, y: 0, color: 'yellow' };

        // Creating the goal, buttom right corner.
        // This is the players goal to reach.
        var goal = {
        x: cols - 1,
        y: rows - 1
        };

        // Creating a Function to generate a maze using the alghorithm. 
        // DFS stands for Depth-First Search
        function generateMazeDFS(){
        // First I'm filling the maze completely with walls (1)
        maze = []; // Start with an empty array to hold the maze
        for(var y=0; y<rows; y++){ // Loops through each row
        maze[y]=[]; // Create a new array for this row
        for(var x=0;x<cols;x++) // Loop through each column
        maze[y][x]=1; // Fills this cell with 1 or walls
        }

        // This is the main Boss, the core alghorithm that actually creates a maze. 
        // creating a function to carve paths. 
        function carve(x,y){
        maze[y][x]=0; // mark current cell as empty/path. 
        // creating an array that stores all the possible directions- 
        // -the algorithm can move from the current cell.
        // for example [1, 0] means go 1 cell right, 0 cells down. move right
        // Possible directions to move: up, right, down, left
        var dirs=[[0,-1],[1,0],[0,1],[-1,0]];
        
        // Shuffle directions to make maze random
        for(var i=dirs.length-1;i>0;i--){
            var j=Math.floor(Math.random()*(i+1));
            [dirs[i],dirs[j]]=[dirs[j],dirs[i]];
            }
            
        // Try moving in each direction
        for(var i=0;i<dirs.length;i++){
            var nx=x+dirs[i][0]*2; // Move 2 cells to skip a wall
            var ny=y+dirs[i][1]*2;
            
        // Check if new position is inside maze bounds and not yet carved
        if(nx>=0 && nx<cols && ny>=0 && ny<rows && maze[ny][nx]===1){
            maze[y+dirs[i][1]][x+dirs[i][0]]=0; // Remove wall between
            carve(nx,ny); // Recursive call to carve next cell
                }
            }
        }   

        carve(0,0); // Start carving from top-left
        maze[0][0]=0; // Make sure that starting point is empty
        maze[rows-1][cols-1]=0; // Make sure that the goal is empty
        }

        /*// Generates a random bright-ish color using HSL
        // This had some bugs that i didn't had the time to fix, but it looks fun.
        // Everytime the player moves the colors of the walls changes randomly.
        function randomColor() {
        return "hsl(" + Math.floor(Math.random() * 360) + ", 70%, 50%)";
        }*/

        // Function to draw grid and player
        function draw() {
                // Clear the canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw the grid
                //creating a for-loop to go through each row to help draw the maze grid
                for (var y = 0; y < rows; y++) {
                    for (var x = 0; x < cols; x++) {
                        /*ctx.fillStyle = maze[y][x] === 1 ? randomColor() : '#111';*/
                        ctx.fillStyle = maze[y][x] === 1 ? '#3d1f5b' : '#111';
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);

                        ctx.strokeStyle = '#111';
                        ctx.strokeRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    }
                }
                
                // Coloring and filling the goal.
                ctx.fillStyle = 'white';
                ctx.fillRect(goal.x * tileSize, goal.y * tileSize, tileSize, tileSize);

                // Draw the player
                ctx.fillStyle = player.color;
                // Here we're multiplying players position with the tilesize 
                // to convert from tile units to pixels
                // We use the same value (tileSize) for width and height
                // because each tile in the maze is a square
                ctx.fillRect(player.x * tileSize, player.y * tileSize, tileSize, tileSize);
        }

        var maze = [];
        generateMazeDFS(); // fill maze with walls and paths
        draw();            // now draw the first maze

        // Function to move player
        function movePlayer(horizontalMove, verticalMove) {
            var newCol = player.x + horizontalMove;
            var newRow = player.y + verticalMove;

            // Keep player inside the grid
            if (newCol >= 0 && newCol < cols && newRow >= 0 && newRow < rows && maze[newRow][newCol] === 0) {
            player.x = newCol;
            player.y = newRow;
            checkWin(); // check if the player won
            }

            // Redraw everything
            //Every time the player moves, the canvas needs to be redrawn. 
            draw();
        }

        // Check if player reaches goal
        function checkWin() {
        // If player is in the same column, row as the goal.
        // Then we get the allert.
          if(player.x === goal.x && player.y === goal.y){
        alert("ðŸŽ‰ You made it! Press OK for a new random maze.");
        player.x = 0; player.y = 0;
        generateMazeDFS();
        draw();
        }
        }

        // Arrow keys 
        window.addEventListener('keydown', function(e) {
            switch (e.key) {
                case "ArrowUp": movePlayer(0, -1); break;
                case "ArrowDown": movePlayer(0, 1); break;
                case "ArrowLeft": movePlayer(-1, 0); break;
                case "ArrowRight": movePlayer(1, 0); break;
            }
        });

        //
        document.getElementById('resetBtn').addEventListener('click', function(){
        player.x=0; player.y=0;
        generateMazeDFS();
        draw();
        });
        
        /*document.getElementById('restartBtn').addEventListener('click', function(){
        player.x=0; player.y=0;
        generateMazeDFS();
        draw();
        });*/

        console.log("This was harder than I thought!");
    </script>

</body>

</html>